// pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
// pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
// pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
// pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
// pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
// pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
// pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
// pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
// pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
// pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
// pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
// pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
// pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
// pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
// pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
// pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
// pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
// pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
// pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
// pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
// pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
// pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
// pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
// pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
// pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
// pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
// pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
// pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
// pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
// pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
// pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
// pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
// pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
// pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
// pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
// pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
// pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
// pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
// pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
// pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
// pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
// pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
// pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
// pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
// pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
// pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
// pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
// pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
// pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
// pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
// pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
// pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
// pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
// pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
// pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
// pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
// pub const __u_char = u8;
// pub const __u_short = c_ushort;
// pub const __u_int = c_uint;
// pub const __u_long = c_ulong;
// pub const __int8_t = i8;
// pub const __uint8_t = u8;
// pub const __int16_t = c_short;
// pub const __uint16_t = c_ushort;
// pub const __int32_t = c_int;
// pub const __uint32_t = c_uint;
// pub const __int64_t = c_long;
// pub const __uint64_t = c_ulong;
// pub const __int_least8_t = __int8_t;
// pub const __uint_least8_t = __uint8_t;
// pub const __int_least16_t = __int16_t;
// pub const __uint_least16_t = __uint16_t;
// pub const __int_least32_t = __int32_t;
// pub const __uint_least32_t = __uint32_t;
// pub const __int_least64_t = __int64_t;
// pub const __uint_least64_t = __uint64_t;
// pub const __quad_t = c_long;
// pub const __u_quad_t = c_ulong;
// pub const __intmax_t = c_long;
// pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
// pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_ulong;
pub const __off_t = c_long;
pub const __off64_t = c_long;
// pub const __pid_t = c_int;
// pub const __fsid_t = extern struct {
//     __val: [2]c_int = @import("std").mem.zeroes([2]c_int),
// };
// pub const __clock_t = c_long;
// pub const __rlim_t = c_ulong;
// pub const __rlim64_t = c_ulong;
// pub const __id_t = c_uint;
pub const __time_t = c_long;
// pub const __useconds_t = c_uint;
// pub const __suseconds_t = c_long;
// pub const __suseconds64_t = c_long;
// pub const __daddr_t = c_int;
// pub const __key_t = c_int;
// pub const __clockid_t = c_int;
// pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_long;
pub const __blkcnt_t = c_long;
// pub const __blkcnt64_t = c_long;
// pub const __fsblkcnt_t = c_ulong;
// pub const __fsblkcnt64_t = c_ulong;
// pub const __fsfilcnt_t = c_ulong;
// pub const __fsfilcnt64_t = c_ulong;
// pub const __fsword_t = c_long;
// pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
// pub const __syscall_ulong_t = c_ulong;
// pub const __loff_t = __off64_t;
// pub const __caddr_t = [*c]u8;
// pub const __intptr_t = c_long;
// pub const __socklen_t = c_uint;
// pub const __sig_atomic_t = c_int;
pub const struct_dirent = extern struct {
    d_ino: __ino_t = @import("std").mem.zeroes(__ino_t),
    d_off: __off_t = @import("std").mem.zeroes(__off_t),
    d_reclen: c_ushort = @import("std").mem.zeroes(c_ushort),
    d_type: u8 = @import("std").mem.zeroes(u8),
    d_name: [256]u8 = @import("std").mem.zeroes([256]u8),
};
// pub const DT_UNKNOWN: c_int = 0;
// pub const DT_FIFO: c_int = 1;
// pub const DT_CHR: c_int = 2;
pub const DT_DIR: c_int = 4;
// pub const DT_BLK: c_int = 6;
pub const DT_REG: c_int = 8;
// pub const DT_LNK: c_int = 10;
// pub const DT_SOCK: c_int = 12;
// pub const DT_WHT: c_int = 14;
// const enum_unnamed_1 = c_uint;
pub const struct___dirstream = opaque {};
pub const DIR = struct___dirstream;
pub extern fn closedir(__dirp: ?*DIR) c_int;
pub extern fn opendir(__name: [*c]const u8) ?*DIR;
pub extern fn readdir(__dirp: ?*DIR) [*c]struct_dirent;
pub const struct_timespec = extern struct {
    tv_sec: __time_t = @import("std").mem.zeroes(__time_t),
    tv_nsec: __syscall_slong_t = @import("std").mem.zeroes(__syscall_slong_t),
};
pub const struct_stat = extern struct {
    st_dev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_ino: __ino_t = @import("std").mem.zeroes(__ino_t),
    st_nlink: __nlink_t = @import("std").mem.zeroes(__nlink_t),
    st_mode: __mode_t = @import("std").mem.zeroes(__mode_t),
    st_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    st_gid: __gid_t = @import("std").mem.zeroes(__gid_t),
    __pad0: c_int = @import("std").mem.zeroes(c_int),
    st_rdev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_size: __off_t = @import("std").mem.zeroes(__off_t),
    st_blksize: __blksize_t = @import("std").mem.zeroes(__blksize_t),
    st_blocks: __blkcnt_t = @import("std").mem.zeroes(__blkcnt_t),
    st_atim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_mtim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_ctim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    __glibc_reserved: [3]__syscall_slong_t = @import("std").mem.zeroes([3]__syscall_slong_t),
};
pub extern fn stat(noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat) c_int;
pub extern fn mkdir(__path: [*c]const u8, __mode: __mode_t) c_int;
pub const chtype = c_uint;
pub const struct__IO_marker = opaque {};
pub const _IO_lock_t = anyopaque;
pub const struct__IO_codecvt = opaque {};
pub const struct__IO_wide_data = opaque {};
pub const struct__IO_FILE = extern struct {
    _flags: c_int = @import("std").mem.zeroes(c_int),
    _IO_read_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_backup_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _markers: ?*struct__IO_marker = @import("std").mem.zeroes(?*struct__IO_marker),
    _chain: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _fileno: c_int = @import("std").mem.zeroes(c_int),
    _flags2: c_int = @import("std").mem.zeroes(c_int),
    _old_offset: __off_t = @import("std").mem.zeroes(__off_t),
    _cur_column: c_ushort = @import("std").mem.zeroes(c_ushort),
    _vtable_offset: i8 = @import("std").mem.zeroes(i8),
    _shortbuf: [1]u8 = @import("std").mem.zeroes([1]u8),
    _lock: ?*_IO_lock_t = @import("std").mem.zeroes(?*_IO_lock_t),
    _offset: __off64_t = @import("std").mem.zeroes(__off64_t),
    _codecvt: ?*struct__IO_codecvt = @import("std").mem.zeroes(?*struct__IO_codecvt),
    _wide_data: ?*struct__IO_wide_data = @import("std").mem.zeroes(?*struct__IO_wide_data),
    _freeres_list: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _freeres_buf: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __pad5: usize = @import("std").mem.zeroes(usize),
    _mode: c_int = @import("std").mem.zeroes(c_int),
    _unused2: [20]u8 = @import("std").mem.zeroes([20]u8),
};
pub const FILE = struct__IO_FILE;
pub extern var stderr: [*c]FILE;
pub extern fn fclose(__stream: [*c]FILE) c_int;
pub extern fn fopen(__filename: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn fprintf(__stream: [*c]FILE, __format: [*c]const u8, ...) c_int;
pub extern fn sprintf(__s: [*c]u8, __format: [*c]const u8, ...) c_int;
pub extern fn asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn fgets(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __n: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __n: c_ulong, __s: [*c]FILE) c_ulong;
pub extern fn fseek(__stream: [*c]FILE, __off: c_long, __whence: c_int) c_int;
pub extern fn ftell(__stream: [*c]FILE) c_long;
pub extern fn pclose(__stream: [*c]FILE) c_int;
pub extern fn popen(__command: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub const attr_t = chtype;
pub const struct_ldat = opaque {};
pub const WINDOW = struct__win_st;
pub const struct_pdat_4 = extern struct {
    _pad_y: c_short = @import("std").mem.zeroes(c_short),
    _pad_x: c_short = @import("std").mem.zeroes(c_short),
    _pad_top: c_short = @import("std").mem.zeroes(c_short),
    _pad_left: c_short = @import("std").mem.zeroes(c_short),
    _pad_bottom: c_short = @import("std").mem.zeroes(c_short),
    _pad_right: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct__win_st = extern struct {
    _cury: c_short = @import("std").mem.zeroes(c_short),
    _curx: c_short = @import("std").mem.zeroes(c_short),
    _maxy: c_short = @import("std").mem.zeroes(c_short),
    _maxx: c_short = @import("std").mem.zeroes(c_short),
    _begy: c_short = @import("std").mem.zeroes(c_short),
    _begx: c_short = @import("std").mem.zeroes(c_short),
    _flags: c_short = @import("std").mem.zeroes(c_short),
    _attrs: attr_t = @import("std").mem.zeroes(attr_t),
    _bkgd: chtype = @import("std").mem.zeroes(chtype),
    _notimeout: bool = @import("std").mem.zeroes(bool),
    _clear: bool = @import("std").mem.zeroes(bool),
    _leaveok: bool = @import("std").mem.zeroes(bool),
    _scroll: bool = @import("std").mem.zeroes(bool),
    _idlok: bool = @import("std").mem.zeroes(bool),
    _idcok: bool = @import("std").mem.zeroes(bool),
    _immed: bool = @import("std").mem.zeroes(bool),
    _sync: bool = @import("std").mem.zeroes(bool),
    _use_keypad: bool = @import("std").mem.zeroes(bool),
    _delay: c_int = @import("std").mem.zeroes(c_int),
    _line: ?*struct_ldat = @import("std").mem.zeroes(?*struct_ldat),
    _regtop: c_short = @import("std").mem.zeroes(c_short),
    _regbottom: c_short = @import("std").mem.zeroes(c_short),
    _parx: c_int = @import("std").mem.zeroes(c_int),
    _pary: c_int = @import("std").mem.zeroes(c_int),
    _parent: [*c]WINDOW = @import("std").mem.zeroes([*c]WINDOW),
    _pad: struct_pdat_4 = @import("std").mem.zeroes(struct_pdat_4),
    _yoffset: c_short = @import("std").mem.zeroes(c_short),
};
pub extern fn init_color(c_short, c_short, c_short, c_short) c_int;
pub extern fn init_pair(c_short, c_short, c_short) c_int;
pub extern fn wrefresh([*c]WINDOW) c_int;
pub extern var stdscr: [*c]WINDOW;
pub const String_View = extern struct {
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: usize = @import("std").mem.zeroes(usize),
};
pub fn view_create(arg_str: [*c]u8, arg_len: usize) callconv(.C) String_View {
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    return String_View{
        .data = str,
        .len = len,
    };
}
pub extern fn view_cmp(a: String_View, b: String_View) c_int;
pub fn view_starts_with_s(arg_a: String_View, arg_b: String_View) callconv(.C) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return view_cmp(view_create(a.data, b.len), b);
}
pub fn view_ends_with_s(arg_a: String_View, arg_b: String_View) callconv(.C) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return view_cmp(view_create((a.data + a.len) - b.len, b.len), b);
}
pub extern fn view_to_cstr(view: String_View) [*c]u8;
pub extern fn view_trim_left(view: String_View) String_View;
pub extern fn view_trim_right(view: String_View) String_View;
pub extern fn view_contains(haystack: String_View, needle: String_View) c_int;
pub extern fn view_first_of(view: String_View, target: u8) usize;
pub extern fn view_last_of(view: String_View, target: u8) usize;
pub extern fn view_split(view: String_View, c: u8, arr: [*c]String_View, arr_s: usize) usize;
pub extern fn view_chop(view: String_View, c: u8) String_View;
pub extern fn view_rev(view: String_View, data: [*c]u8, data_s: usize) String_View;
pub extern fn view_find(haystack: String_View, needle: String_View) usize;
pub extern fn view_to_int(view: String_View) c_int;
pub extern fn view_to_float(view: String_View) f32;
pub const NORMAL: c_int = 0;
pub const INSERT: c_int = 1;
pub const SEARCH: c_int = 2;
pub const COMMAND: c_int = 3;
pub const VISUAL: c_int = 4;
pub const MODE_COUNT: c_int = 5;
pub const Mode = c_uint;
pub const LEADER_NONE: c_int = 0;
pub const LEADER_R: c_int = 1;
pub const LEADER_D: c_int = 2;
pub const LEADER_Y: c_int = 3;
pub const LEADER_COUNT: c_int = 4;
pub const Leader = c_uint;
pub const NONE: c_int = 0;
pub const INSERT_CHARS: c_int = 1;
pub const DELETE_CHAR: c_int = 2;
pub const DELETE_MULT_CHAR: c_int = 3;
pub const REPLACE_CHAR: c_int = 4;
pub const Undo_Type = c_uint;
pub const NO_ERROR: c_int = 0;
pub const NOT_ENOUGH_ARGS: c_int = 1;
pub const INVALID_ARGS: c_int = 2;
pub const UNKNOWN_COMMAND: c_int = 3;
pub const INVALID_IDENT: c_int = 4;
pub const Command_Error = c_uint;
pub const ThreadArgs = extern struct {
    path_to_file: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    filename: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    lang: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const Color = extern struct {
    color_name: [20]u8 = @import("std").mem.zeroes([20]u8),
    is_custom_line_row: bool = @import("std").mem.zeroes(bool),
    is_custom: bool = @import("std").mem.zeroes(bool),
    slot: c_int = @import("std").mem.zeroes(c_int),
    id: c_int = @import("std").mem.zeroes(c_int),
    red: c_int = @import("std").mem.zeroes(c_int),
    green: c_int = @import("std").mem.zeroes(c_int),
    blue: c_int = @import("std").mem.zeroes(c_int),
};

const buf = @import("buffer.zig");
const Buffer = buf.Buffer;
const Undo_Stack = buf.Undo_Stack;
const Undo = buf.Undo;
const Data = buf.Data;

pub const Arg = extern struct {
    size: usize = @import("std").mem.zeroes(usize),
    arg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const Repeating = extern struct {
    repeating: bool = @import("std").mem.zeroes(bool),
    repeating_count: usize = @import("std").mem.zeroes(usize),
};
pub const Sized_Str = extern struct {
    str: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: usize = @import("std").mem.zeroes(usize),
};
pub const Map = extern struct {
    a: c_int = @import("std").mem.zeroes(c_int),
    b: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    b_s: usize = @import("std").mem.zeroes(usize),
};
pub const Maps = extern struct {
    data: [*c]Map = @import("std").mem.zeroes([*c]Map),
    count: usize = @import("std").mem.zeroes(usize),
    capacity: usize = @import("std").mem.zeroes(usize),
};
pub const Var_Value = extern union {
    as_int: c_int,
    as_float: f32,
    as_ptr: ?*anyopaque,
};
pub const VAR_INT: c_int = 0;
pub const VAR_FLOAT: c_int = 1;
pub const VAR_PTR: c_int = 2;
pub const Var_Type = c_uint;
pub const Variable = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    value: Var_Value = @import("std").mem.zeroes(Var_Value),
    type: Var_Type = @import("std").mem.zeroes(Var_Type),
};
pub const Variables = extern struct {
    data: [*c]Variable = @import("std").mem.zeroes([*c]Variable),
    count: usize = @import("std").mem.zeroes(usize),
    capacity: usize = @import("std").mem.zeroes(usize),
};
pub const File = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    path: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    is_directory: bool = @import("std").mem.zeroes(bool),
};
pub const Files = extern struct {
    data: [*c]File = @import("std").mem.zeroes([*c]File),
    count: usize = @import("std").mem.zeroes(usize),
    capacity: usize = @import("std").mem.zeroes(usize),
};
pub const Config_Vars = extern struct {
    label: String_View = @import("std").mem.zeroes(String_View),
    val: [*c]c_int = @import("std").mem.zeroes([*c]c_int),
};
pub const struct__Config_ = extern struct {
    relative_nums: c_int = @import("std").mem.zeroes(c_int),
    auto_indent: c_int = @import("std").mem.zeroes(c_int),
    syntax: c_int = @import("std").mem.zeroes(c_int),
    indent: c_int = @import("std").mem.zeroes(c_int),
    undo_size: c_int = @import("std").mem.zeroes(c_int),
    lang: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    QUIT: c_int = @import("std").mem.zeroes(c_int),
    mode: Mode = @import("std").mem.zeroes(Mode),
    background_color: c_int = @import("std").mem.zeroes(c_int),
    leaders: [4]u8 = @import("std").mem.zeroes([4]u8),
    key_maps: Maps = @import("std").mem.zeroes(Maps),
    vars: [5]Config_Vars = @import("std").mem.zeroes([5]Config_Vars),
};
pub const Config = struct__Config_;
pub const struct_State = extern struct {
    undo_stack: Undo_Stack = @import("std").mem.zeroes(Undo_Stack),
    redo_stack: Undo_Stack = @import("std").mem.zeroes(Undo_Stack),
    cur_undo: Undo = @import("std").mem.zeroes(Undo),
    num_of_braces: usize = @import("std").mem.zeroes(usize),
    ch: c_int = @import("std").mem.zeroes(c_int),
    env: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    command: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    command_s: usize = @import("std").mem.zeroes(usize),
    variables: Variables = @import("std").mem.zeroes(Variables),
    repeating: Repeating = @import("std").mem.zeroes(Repeating),
    num: Data = @import("std").mem.zeroes(Data),
    leader: Leader = @import("std").mem.zeroes(Leader),
    is_print_msg: bool = @import("std").mem.zeroes(bool),
    status_bar_msg: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    x: usize = @import("std").mem.zeroes(usize),
    y: usize = @import("std").mem.zeroes(usize),
    normal_pos: usize = @import("std").mem.zeroes(usize),
    key_func: [*c]?*const fn ([*c]Buffer, [*c][*c]Buffer, [*c]struct_State) callconv(.C) void = @import("std").mem.zeroes([*c]?*const fn ([*c]Buffer, [*c][*c]Buffer, [*c]struct_State) callconv(.C) void),
    clipboard: Sized_Str = @import("std").mem.zeroes(Sized_Str),
    files: [*c]Files = @import("std").mem.zeroes([*c]Files),
    is_exploring: bool = @import("std").mem.zeroes(bool),
    explore_cursor: usize = @import("std").mem.zeroes(usize),
    buffer: [*c]Buffer = @import("std").mem.zeroes([*c]Buffer),
    grow: c_int = @import("std").mem.zeroes(c_int),
    gcol: c_int = @import("std").mem.zeroes(c_int),
    main_row: c_int = @import("std").mem.zeroes(c_int),
    main_col: c_int = @import("std").mem.zeroes(c_int),
    line_num_row: c_int = @import("std").mem.zeroes(c_int),
    line_num_col: c_int = @import("std").mem.zeroes(c_int),
    status_bar_row: c_int = @import("std").mem.zeroes(c_int),
    status_bar_col: c_int = @import("std").mem.zeroes(c_int),
    line_num_win: [*c]WINDOW = @import("std").mem.zeroes([*c]WINDOW),
    main_win: [*c]WINDOW = @import("std").mem.zeroes([*c]WINDOW),
    status_bar: [*c]WINDOW = @import("std").mem.zeroes([*c]WINDOW),
    config: Config = @import("std").mem.zeroes(Config),
};
pub const State = struct_State;
pub const Brace = extern struct {
    brace: u8 = @import("std").mem.zeroes(u8),
    closing: c_int = @import("std").mem.zeroes(c_int),
};
pub const Ncurses_Color = extern struct {
    r: c_int = @import("std").mem.zeroes(c_int),
    g: c_int = @import("std").mem.zeroes(c_int),
    b: c_int = @import("std").mem.zeroes(c_int),
};
pub const Syntax_Highlighting = extern struct {
    row: usize = @import("std").mem.zeroes(usize),
    col: usize = @import("std").mem.zeroes(usize),
    size: usize = @import("std").mem.zeroes(usize),
};
pub extern var string_modes: [5][*c]u8;
pub extern fn buffer_calculate_rows(buffer: [*c]Buffer) void;
pub extern fn buffer_insert_char(state: [*c]State, buffer: [*c]Buffer, ch: u8) void;
pub extern fn buffer_delete_char(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_delete_ch(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_replace_ch(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_delete_row(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_get_row(buffer: [*c]const Buffer) usize;
pub extern fn index_get_row(buffer: [*c]Buffer, index: usize) usize;
pub extern fn buffer_yank_line(buffer: [*c]Buffer, state: [*c]State, offset: usize) void;
pub extern fn buffer_yank_char(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_yank_selection(buffer: [*c]Buffer, state: [*c]State, start: usize, end: usize) void;
pub extern fn buffer_delete_selection(buffer: [*c]Buffer, state: [*c]State, start: usize, end: usize) void;
pub extern fn buffer_insert_selection(buffer: [*c]Buffer, selection: [*c]Data, start: usize) void;
pub extern fn buffer_move_up(buffer: [*c]Buffer) void;
pub extern fn buffer_move_down(buffer: [*c]Buffer) void;
pub extern fn buffer_move_right(buffer: [*c]Buffer) void;
pub extern fn buffer_move_left(buffer: [*c]Buffer) void;
pub extern fn skip_to_char(buffer: [*c]Buffer, cur_pos: c_int, direction: c_int, c: u8) c_int;
pub extern fn buffer_next_brace(buffer: [*c]Buffer) void;
pub extern fn isword(ch: u8) c_int;
pub extern fn buffer_create_indent(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn buffer_newline_indent(buffer: [*c]Buffer, state: [*c]State) void;
pub extern fn init_state() State;
pub const ptrdiff_t = c_long;
pub const wchar_t = c_int;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8) = @import("std").mem.zeroes(c_longlong),
    __clang_max_align_nonce2: c_longdouble align(16) = @import("std").mem.zeroes(c_longdouble),
};
pub extern fn frontend_init(state: [*c]State) void;
pub extern fn state_render(state: [*c]State) void;
pub extern fn frontend_resize_window(state: [*c]State) void;
pub extern fn frontend_getch(window: [*c]WINDOW) c_int;
pub extern fn frontend_move_cursor(window: [*c]WINDOW, pos_x: usize, pos_y: usize) void;
pub extern fn frontend_cursor_visible(value: c_int) void;
pub extern fn frontend_end() void;
pub const TT_SET_VAR: c_int = 0;
pub const TT_SET_OUTPUT: c_int = 1;
pub const TT_SET_MAP: c_int = 2;
pub const TT_LET: c_int = 3;
pub const TT_PLUS: c_int = 4;
pub const TT_MINUS: c_int = 5;
pub const TT_MULT: c_int = 6;
pub const TT_DIV: c_int = 7;
pub const TT_ECHO: c_int = 8;
pub const TT_SAVE: c_int = 9;
pub const TT_EXIT: c_int = 10;
pub const TT_SAVE_EXIT: c_int = 11;
pub const TT_IDENT: c_int = 12;
pub const TT_SPECIAL_CHAR: c_int = 13;
pub const TT_STRING: c_int = 14;
pub const TT_CONFIG_IDENT: c_int = 15;
pub const TT_INT_LIT: c_int = 16;
pub const TT_FLOAT_LIT: c_int = 17;
pub const TT_COUNT: c_int = 18;
pub const Command_Type = c_uint;
pub const Command_Token = extern struct {
    type: Command_Type = @import("std").mem.zeroes(Command_Type),
    value: String_View = @import("std").mem.zeroes(String_View),
    location: usize = @import("std").mem.zeroes(usize),
};
pub const Identifier = extern struct {
    name: String_View = @import("std").mem.zeroes(String_View),
    value: c_int = @import("std").mem.zeroes(c_int),
};
pub const Str_Literal = extern struct {
    value: String_View = @import("std").mem.zeroes(String_View),
};
pub const Expr = extern struct {
    value: c_int = @import("std").mem.zeroes(c_int),
};
pub const OP_NONE: c_int = 0;
pub const OP_PLUS: c_int = 1;
pub const OP_MINUS: c_int = 2;
pub const OP_MULT: c_int = 3;
pub const OP_DIV: c_int = 4;
pub const Operator = c_uint;
pub const struct_Bin_Expr = extern struct {
    lvalue: Expr = @import("std").mem.zeroes(Expr),
    right: [*c]struct_Bin_Expr = @import("std").mem.zeroes([*c]struct_Bin_Expr),
    rvalue: Expr = @import("std").mem.zeroes(Expr),
    operator: Operator = @import("std").mem.zeroes(Operator),
};
pub const Bin_Expr = struct_Bin_Expr;
pub const Node_Val = extern union {
    as_expr: Expr,
    as_bin: Bin_Expr,
    as_keyword: Command_Type,
    as_str: Str_Literal,
    as_ident: Identifier,
    as_config: [*c]Config_Vars,
    as_int: c_int,
};
pub const NODE_EXPR: c_int = 0;
pub const NODE_BIN: c_int = 1;
pub const NODE_KEYWORD: c_int = 2;
pub const NODE_STR: c_int = 3;
pub const NODE_IDENT: c_int = 4;
pub const NODE_CONFIG: c_int = 5;
pub const NODE_INT: c_int = 6;
pub const Node_Type = c_uint;
pub const struct_Node = extern struct {
    value: Node_Val = @import("std").mem.zeroes(Node_Val),
    type: Node_Type = @import("std").mem.zeroes(Node_Type),
    left: [*c]struct_Node = @import("std").mem.zeroes([*c]struct_Node),
    right: [*c]struct_Node = @import("std").mem.zeroes([*c]struct_Node),
};
pub const Node = struct_Node;
pub const Ctrl_Key = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    value: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn get_token_type(state: [*c]State, view: String_View) Command_Type;
pub extern fn create_token(state: [*c]State, command: String_View) Command_Token;
pub extern fn lex_command(state: [*c]State, command: String_View, token_s: [*c]usize) [*c]Command_Token;
pub extern fn print_token(token: Command_Token) void;
pub extern fn expect_token(state: [*c]State, token: Command_Token, @"type": Command_Type) c_int;
pub extern fn create_node(@"type": Node_Type, value: Node_Val) [*c]Node;
pub extern fn get_operator(token: Command_Token) Operator;
pub extern fn get_special_char(view: String_View) c_int;
pub extern fn parse_bin_expr(state: [*c]State, command: [*c]Command_Token, command_s: usize) [*c]Bin_Expr;
pub extern fn parse_command(state: [*c]State, command: [*c]Command_Token, command_s: usize) [*c]Node;
pub extern fn interpret_expr(expr: [*c]Bin_Expr) c_int;
pub extern fn interpret_command(buffer: [*c]Buffer, state: [*c]State, root: [*c]Node) void;
pub extern fn print_tree(node: [*c]Node, depth: usize) void;
pub extern fn execute_command(buffer: [*c]Buffer, state: [*c]State, command: [*c]Command_Token, command_s: usize) c_int;
pub const YELLOW_COLOR: c_int = 1;
pub const BLUE_COLOR: c_int = 2;
pub const GREEN_COLOR: c_int = 3;
pub const RED_COLOR: c_int = 4;
pub const CYAN_COLOR: c_int = 5;
pub const MAGENTA_COLOR: c_int = 6;
pub const Color_Pairs = c_uint;
pub const Custom_Color = extern struct {
    custom_slot: Color_Pairs = @import("std").mem.zeroes(Color_Pairs),
    custom_id: c_int = @import("std").mem.zeroes(c_int),
    custom_r: c_int = @import("std").mem.zeroes(c_int),
    custom_g: c_int = @import("std").mem.zeroes(c_int),
    custom_b: c_int = @import("std").mem.zeroes(c_int),
};
pub const Color_Arr = extern struct {
    arr: [*c]Custom_Color = @import("std").mem.zeroes([*c]Custom_Color),
    arr_s: usize = @import("std").mem.zeroes(usize),
};
pub const div_t = extern struct {
    quot: c_int = @import("std").mem.zeroes(c_int),
    rem: c_int = @import("std").mem.zeroes(c_int),
};
pub const ldiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub const lldiv_t = extern struct {
    quot: c_longlong = @import("std").mem.zeroes(c_longlong),
    rem: c_longlong = @import("std").mem.zeroes(c_longlong),
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn system(__command: [*c]const u8) c_int;
pub const __compar_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strlen(__s: [*c]const u8) c_ulong;

pub const Type_None: c_int = 0;
pub const Type_Keyword: c_int = 1;
pub const Type_Type: c_int = 2;
pub const Type_Preprocessor: c_int = 3;
pub const Type_String: c_int = 4;
pub const Type_Comment: c_int = 5;
pub const Type_Word: c_int = 6;
pub const Token_Type = c_uint;
pub const Token = extern struct {
    type: Token_Type = @import("std").mem.zeroes(Token_Type),
    index: usize = @import("std").mem.zeroes(usize),
    size: usize = @import("std").mem.zeroes(usize),
};
pub extern fn is_keyword(word: [*c]u8, word_s: usize) c_int;
pub extern fn is_type(word: [*c]u8, word_s: usize) c_int;
pub extern fn strip_off_dot(str: [*c]u8, str_s: usize) [*c]u8;
pub extern fn read_file_to_str(filename: [*c]u8, contents: [*c][*c]u8) usize;
pub extern fn parse_syntax_file(filename: [*c]u8) Color_Arr;
pub extern fn is_in_tokens_index(token_arr: [*c]Token, token_s: usize, index: usize, size: [*c]usize, color: [*c]Color_Pairs) c_int;
pub extern fn generate_word(view: [*c]String_View, contents: [*c]u8) Token;
pub extern fn generate_tokens(line: [*c]u8, line_s: usize, token_arr: [*c]Token, token_arr_capacity: [*c]usize) usize;
pub extern fn read_file_by_lines(filename: [*c]u8, lines: [*c][*c][*c]u8, lines_s: [*c]usize) c_int;
pub export fn dynstr_to_data(arg_str: Sized_Str) Data {
    var str = arg_str;
    _ = &str;
    return Data{
        .data = str.str,
        .count = str.len,
        .capacity = str.len,
    };
}

pub export fn handle_cursor_shape(state: [*c]State) void {
    while (true) {
        switch (state.*.config.mode) {
            @as(c_uint, @bitCast(@as(c_int, 0))), @as(c_uint, @bitCast(@as(c_int, 4))), @as(c_uint, @bitCast(@as(c_int, 3))), @as(c_uint, @bitCast(@as(c_int, 2))) => {
                _ = system("echo -e -n \"\x1b[0 q\"");
                _ = wrefresh(stdscr);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                _ = system("echo -e -n \"\x1b[5 q\"");
                _ = wrefresh(stdscr);
                break;
            },
            else => {
                while (true) {
                    if (!(@as(c_int, 0) != 0)) {
                        frontend_end();
                        _ = fprintf(stderr, "%s:%d: ASSERTION FAILED: ", "src/tools.c", @as(c_int, 33));
                        _ = fprintf(stderr, "unreachable");
                        _ = fprintf(stderr, "\n");
                        exit(@as(c_int, 1));
                    }
                    if (!false) break;
                }
            },
        }
        break;
    }
}

pub export fn free_buffer(arg_buffer: [*c]Buffer) void {
    var buffer = arg_buffer;
    _ = &buffer;
    free(@as(?*anyopaque, @ptrCast(buffer.*.data.data)));
    free(@as(?*anyopaque, @ptrCast(buffer.*.rows.data)));
    free(@as(?*anyopaque, @ptrCast(buffer.*.filename)));
    buffer.*.data.count = 0;
    buffer.*.rows.count = 0;
    buffer.*.data.capacity = 0;
    buffer.*.rows.capacity = 0;
}

pub export fn free_undo(arg_undo: [*c]Undo) void {
    var undo = arg_undo;
    _ = &undo;
    free(@as(?*anyopaque, @ptrCast(undo.*.data.data)));
}

pub export fn free_undo_stack(arg_undo: [*c]Undo_Stack) void {
    var undo = arg_undo;
    _ = &undo;
    {
        var i: usize = 0;
        _ = &i;
        while (i < undo.*.count) : (i +%= 1) {
            free_undo(&undo.*.data[i]);
        }
    }
    free(@as(?*anyopaque, @ptrCast(undo.*.data)));
}

pub export fn handle_save(arg_buffer: [*c]Buffer) void {
    var buffer = arg_buffer;
    _ = &buffer;
    var file: [*c]FILE = fopen(buffer.*.filename, "w");
    _ = &file;
    _ = fwrite(@as(?*const anyopaque, @ptrCast(buffer.*.data.data)), buffer.*.data.count, @sizeOf(u8), file);
    _ = fclose(file);
}
pub export fn load_buffer_from_file(arg_filename: [*c]u8) [*c]Buffer {
    var filename = arg_filename;
    _ = &filename;
    var buffer: [*c]Buffer = @as([*c]Buffer, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(Buffer)))));
    _ = &buffer;
    var filename_s: usize = strlen(filename) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
    _ = &filename_s;
    buffer.*.filename = @as([*c]u8, @ptrCast(@alignCast(calloc(filename_s, @sizeOf(u8)))));
    _ = strncpy(buffer.*.filename, filename, filename_s);
    var file: [*c]FILE = fopen(filename, "a+");
    _ = &file;
    if (file == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) while (true) {
        frontend_end();
        _ = fprintf(stderr, "Could not open file\n");
        exit(@as(c_int, 1));
        if (!false) break;
    };
    _ = fseek(file, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 2));
    var length: usize = @as(usize, @bitCast(ftell(file)));
    _ = &length;
    _ = fseek(file, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 0));
    buffer.*.data.count = length;
    buffer.*.data.capacity = (length +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) *% @as(usize, @bitCast(@as(c_long, @as(c_int, 2))));
    buffer.*.data.data = @as([*c]u8, @ptrCast(@alignCast(calloc(buffer.*.data.capacity +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(u8)))));
    while (true) {
        if (!(buffer.*.data.data != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))))) {
            frontend_end();
            _ = fprintf(stderr, "%s:%d: ASSERTION FAILED: ", "src/tools.c", @as(c_int, 83));
            _ = fprintf(stderr, "buffer allocated properly");
            _ = fprintf(stderr, "\n");
            exit(@as(c_int, 1));
        }
        if (!false) break;
    }
    _ = fread(@as(?*anyopaque, @ptrCast(buffer.*.data.data)), length, @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), file);
    _ = fclose(file);
    buffer_calculate_rows(buffer);
    return buffer;
}
pub export fn shift_str_left(arg_str: [*c]u8, arg_str_s: [*c]usize, arg_index_1: usize) void {
    var str = arg_str;
    _ = &str;
    var str_s = arg_str_s;
    _ = &str_s;
    var index_1 = arg_index_1;
    _ = &index_1;
    {
        var i: usize = index_1;
        _ = &i;
        while (i < str_s.*) : (i +%= 1) {
            str[i] = str[i +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))];
        }
    }
    str_s.* -%= @as(usize, @bitCast(@as(c_long, @as(c_int, 1))));
}
pub export fn shift_str_right(arg_str: [*c]u8, arg_str_s: [*c]usize, arg_index_1: usize) void {
    var str = arg_str;
    _ = &str;
    var str_s = arg_str_s;
    _ = &str_s;
    var index_1 = arg_index_1;
    _ = &index_1;
    str_s.* +%= @as(usize, @bitCast(@as(c_long, @as(c_int, 1))));
    {
        var i: usize = str_s.*;
        _ = &i;
        while (i > index_1) : (i -%= 1) {
            str[i] = str[i -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))];
        }
    }
}
pub export fn undo_push(arg_state: [*c]State, arg_stack: [*c]Undo_Stack, arg_undo: Undo) void {
    var state = arg_state;
    _ = &state;
    var stack = arg_stack;
    _ = &stack;
    var undo = arg_undo;
    _ = &undo;
    while (true) {
        if (stack.*.count >= stack.*.capacity) {
            stack.*.capacity = if (stack.*.capacity == @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(usize, @bitCast(@as(c_long, @as(c_int, 1024)))) else stack.*.capacity *% @as(usize, @bitCast(@as(c_long, @as(c_int, 2))));
            var new: ?*anyopaque = calloc(stack.*.capacity +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(Undo));
            _ = &new;
            while (true) {
                if (!(new != null)) {
                    frontend_end();
                    _ = fprintf(stderr, "%s:%d: ASSERTION FAILED: ", "src/tools.c", @as(c_int, 105));
                    _ = fprintf(stderr, "outta ram");
                    _ = fprintf(stderr, "\n");
                    exit(@as(c_int, 1));
                }
                if (!false) break;
            }
            _ = memcpy(new, @as(?*const anyopaque, @ptrCast(stack.*.data)), stack.*.count);
            free(@as(?*anyopaque, @ptrCast(stack.*.data)));
            stack.*.data = @as([*c]Undo, @ptrCast(@alignCast(new)));
        }
        stack.*.data[
            blk: {
                const ref = &stack.*.count;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }
        ] = undo;
        if (!false) break;
    }
    state.*.cur_undo = Undo{
        .type = @as(c_uint, @bitCast(@as(c_int, 0))),
        .data = @import("std").mem.zeroes(Data),
        .start = @import("std").mem.zeroes(usize),
        .end = @import("std").mem.zeroes(usize),
    };
}
pub export fn undo_pop(arg_stack: [*c]Undo_Stack) Undo {
    var stack = arg_stack;
    _ = &stack;
    if (stack.*.count <= @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) return Undo{
        .type = @as(c_uint, @bitCast(@as(c_int, 0))),
        .data = @import("std").mem.zeroes(Data),
        .start = @import("std").mem.zeroes(usize),
        .end = @import("std").mem.zeroes(usize),
    };
    return stack.*.data[
        blk: {
            const ref = &stack.*.count;
            ref.* -%= 1;
            break :blk ref.*;
        }
    ];
}
pub export fn find_opposite_brace(arg_opening: u8) Brace {
    var opening = arg_opening;
    _ = &opening;
    while (true) {
        switch (@as(c_int, @bitCast(@as(c_uint, opening)))) {
            @as(c_int, 40) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, ')'))))),
                .closing = @as(c_int, 0),
            },
            @as(c_int, 123) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '}'))))),
                .closing = @as(c_int, 0),
            },
            @as(c_int, 91) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, ']'))))),
                .closing = @as(c_int, 0),
            },
            @as(c_int, 41) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '('))))),
                .closing = @as(c_int, 1),
            },
            @as(c_int, 125) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '{'))))),
                .closing = @as(c_int, 1),
            },
            @as(c_int, 93) => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '['))))),
                .closing = @as(c_int, 1),
            },
            else => return Brace{
                .brace = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '0'))))),
                .closing = 0,
            },
        }
        break;
    }
    return @import("std").mem.zeroes(Brace);
}
pub export fn check_keymaps(arg_buffer: [*c]Buffer, arg_state: [*c]State) c_int {
    var buffer = arg_buffer;
    _ = &buffer;
    var state = arg_state;
    _ = &state;
    _ = &buffer;
    {
        var i: usize = 0;
        _ = &i;
        while (i < state.*.config.key_maps.count) : (i +%= 1) {
            if (state.*.ch == state.*.config.key_maps.data[i].a) {
                {
                    var j: usize = 0;
                    _ = &j;
                    while (j < state.*.config.key_maps.data[i].b_s) : (j +%= 1) {
                        state.*.ch = @as(c_int, @bitCast(@as(c_uint, state.*.config.key_maps.data[i].b[j])));
                        state.*.key_func[state.*.config.mode].?(buffer, &buffer, state);
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}
pub export fn scan_files(arg_state: [*c]State, arg_directory: [*c]u8) void {
    var state = arg_state;
    _ = &state;
    var directory = arg_directory;
    _ = &directory;
    var dp: ?*DIR = opendir(directory);
    _ = &dp;
    if (dp == @as(?*DIR, @ptrCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))) {
        while (true) {
            var file: [*c]FILE = fopen("logs/cano.log", "a");
            _ = &file;
            if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                _ = fprintf(file, "%s:%d: Failed to open directory: %s\n\n", "src/tools.c", @as(c_int, 163), directory);
                _ = fclose(file);
            }
            if (!false) break;
        }
        while (true) {
            frontend_end();
            _ = fprintf(stderr, "Failed to open directory\n");
            exit(@as(c_int, 1));
            if (!false) break;
        }
    }
    var dent: [*c]struct_dirent = undefined;
    _ = &dent;
    while ((blk: {
        const tmp = readdir(dp);
        dent = tmp;
        break :blk tmp;
    }) != @as([*c]struct_dirent, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        if (strcmp(@as([*c]u8, @ptrCast(@alignCast(&dent.*.d_name))), ".") == @as(c_int, 0)) continue;
        var path: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256)))), @sizeOf(u8)))));
        _ = &path;
        _ = strcpy(path, directory);
        _ = strcat(path, "/");
        _ = strcat(path, @as([*c]u8, @ptrCast(@alignCast(&dent.*.d_name))));
        var name: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 256)))), @sizeOf(u8)))));
        _ = &name;
        _ = strcpy(name, @as([*c]u8, @ptrCast(@alignCast(&dent.*.d_name))));
        if (@as(c_int, @bitCast(@as(c_uint, dent.*.d_type))) == DT_DIR) {
            _ = strcat(name, "/");
            while (true) {
                if (state.*.files.*.count >= state.*.files.*.capacity) {
                    state.*.files.*.capacity = if (state.*.files.*.capacity == @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(usize, @bitCast(@as(c_long, @as(c_int, 1024)))) else state.*.files.*.capacity *% @as(usize, @bitCast(@as(c_long, @as(c_int, 2))));
                    var new: ?*anyopaque = calloc(state.*.files.*.capacity +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(File));
                    _ = &new;
                    while (true) {
                        if (!(new != null)) {
                            frontend_end();
                            _ = fprintf(stderr, "%s:%d: ASSERTION FAILED: ", "src/tools.c", @as(c_int, 182));
                            _ = fprintf(stderr, "outta ram");
                            _ = fprintf(stderr, "\n");
                            exit(@as(c_int, 1));
                        }
                        if (!false) break;
                    }
                    _ = memcpy(new, @as(?*const anyopaque, @ptrCast(state.*.files.*.data)), state.*.files.*.count);
                    free(@as(?*anyopaque, @ptrCast(state.*.files.*.data)));
                    state.*.files.*.data = @as([*c]File, @ptrCast(@alignCast(new)));
                }
                state.*.files.*.data[
                    blk: {
                        const ref = &state.*.files.*.count;
                        const tmp = ref.*;
                        ref.* +%= 1;
                        break :blk tmp;
                    }
                ] = File{
                    .name = name,
                    .path = path,
                    .is_directory = @as(c_int, 1) != 0,
                };
                if (!false) break;
            }
        } else if (@as(c_int, @bitCast(@as(c_uint, dent.*.d_type))) == DT_REG) {
            while (true) {
                if (state.*.files.*.count >= state.*.files.*.capacity) {
                    state.*.files.*.capacity = if (state.*.files.*.capacity == @as(usize, @bitCast(@as(c_long, @as(c_int, 0))))) @as(usize, @bitCast(@as(c_long, @as(c_int, 1024)))) else state.*.files.*.capacity *% @as(usize, @bitCast(@as(c_long, @as(c_int, 2))));
                    var new: ?*anyopaque = calloc(state.*.files.*.capacity +% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))), @sizeOf(File));
                    _ = &new;
                    while (true) {
                        if (!(new != null)) {
                            frontend_end();
                            _ = fprintf(stderr, "%s:%d: ASSERTION FAILED: ", "src/tools.c", @as(c_int, 184));
                            _ = fprintf(stderr, "outta ram");
                            _ = fprintf(stderr, "\n");
                            exit(@as(c_int, 1));
                        }
                        if (!false) break;
                    }
                    _ = memcpy(new, @as(?*const anyopaque, @ptrCast(state.*.files.*.data)), state.*.files.*.count);
                    free(@as(?*anyopaque, @ptrCast(state.*.files.*.data)));
                    state.*.files.*.data = @as([*c]File, @ptrCast(@alignCast(new)));
                }
                state.*.files.*.data[
                    blk: {
                        const ref = &state.*.files.*.count;
                        const tmp = ref.*;
                        ref.* +%= 1;
                        break :blk tmp;
                    }
                ] = File{
                    .name = name,
                    .path = path,
                    .is_directory = @as(c_int, 0) != 0,
                };
                if (!false) break;
            }
        }
    }
    _ = closedir(dp);
    qsort(@as(?*anyopaque, @ptrCast(state.*.files.*.data)), state.*.files.*.count, @sizeOf(File), @as(__compar_fn_t, @ptrCast(@alignCast(&compare_name))));
}
pub export fn free_files(arg_files: [*c][*c]Files) void {
    var files = arg_files;
    _ = &files;
    {
        var i: usize = 0;
        _ = &i;
        while (i < files.*.*.count) : (i +%= 1) {
            free(@as(?*anyopaque, @ptrCast(files.*.*.data[i].name)));
            free(@as(?*anyopaque, @ptrCast(files.*.*.data[i].path)));
        }
    }
    free(@as(?*anyopaque, @ptrCast(files.*.*.data)));
    free(@as(?*anyopaque, @ptrCast(files.*)));
}
pub export fn load_config_from_file(arg_state: [*c]State, arg_buffer: [*c]Buffer, arg_config_filename: [*c]u8, arg_syntax_filename: [*c]u8) void {
    var state = arg_state;
    _ = &state;
    var buffer = arg_buffer;
    _ = &buffer;
    var config_filename = arg_config_filename;
    _ = &config_filename;
    var syntax_filename = arg_syntax_filename;
    _ = &syntax_filename;
    var config_dir: [*c]u8 = undefined;
    _ = &config_dir;
    if (config_filename == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        if (state.*.env == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            var env: [*c]u8 = getenv("HOME");
            _ = &env;
            if (env == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) while (true) {
                frontend_end();
                _ = fprintf(stderr, "could not get HOME\n");
                exit(@as(c_int, 1));
                if (!false) break;
            };
            state.*.env = env;
        }
        _ = asprintf(&config_dir, "%s/.config/cano", state.*.env);
        var st: struct_stat = undefined;
        _ = &st;
        if (stat(config_dir, &st) == -@as(c_int, 1)) {
            _ = mkdir(config_dir, @as(__mode_t, @bitCast(@as(c_int, 493))));
        }
        if (!((st.st_mode & @as(__mode_t, @bitCast(@as(c_int, 61440)))) == @as(__mode_t, @bitCast(@as(c_int, 16384))))) while (true) {
            frontend_end();
            _ = fprintf(stderr, "a file conflict with the config directory.\n");
            exit(@as(c_int, 1));
            if (!false) break;
        };
        _ = asprintf(&config_filename, "%s/config.cano", config_dir);
        var language: [*c]u8 = strip_off_dot(buffer.*.filename, strlen(buffer.*.filename));
        _ = &language;
        if (language != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            _ = asprintf(&syntax_filename, "%s/%s.cyntax", config_dir, language);
            free(@as(?*anyopaque, @ptrCast(language)));
        }
    }
    var lines: [*c][*c]u8 = @as([*c][*c]u8, @ptrCast(@alignCast(calloc(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2)))), @sizeOf([*c]u8)))));
    _ = &lines;
    var lines_s: usize = 0;
    _ = &lines_s;
    var err: c_int = read_file_by_lines(config_filename, &lines, &lines_s);
    _ = &err;
    if (err == @as(c_int, 0)) {
        {
            var i: usize = 0;
            _ = &i;
            while (i < lines_s) : (i +%= 1) {
                var cmd_s: usize = 0;
                _ = &cmd_s;
                var cmd: [*c]Command_Token = lex_command(state, view_create(lines[i], strlen(lines[i])), &cmd_s);
                _ = &cmd;
                _ = execute_command(buffer, state, cmd, cmd_s);
                free(@as(?*anyopaque, @ptrCast(lines[i])));
            }
        }
    }
    free(@as(?*anyopaque, @ptrCast(lines)));
    if (syntax_filename != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        var color_arr: Color_Arr = parse_syntax_file(syntax_filename);
        _ = &color_arr;
        if (color_arr.arr != @as([*c]Custom_Color, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            {
                var i: usize = 0;
                _ = &i;
                while (i < color_arr.arr_s) : (i +%= 1) {
                    _ = init_pair(@as(c_short, @bitCast(@as(c_ushort, @truncate(color_arr.arr[i].custom_slot)))), @as(c_short, @bitCast(@as(c_short, @truncate(color_arr.arr[i].custom_id)))), @as(c_short, @bitCast(@as(c_short, @truncate(state.*.config.background_color)))));
                    init_ncurses_color(color_arr.arr[i].custom_id, color_arr.arr[i].custom_r, color_arr.arr[i].custom_g, color_arr.arr[i].custom_b);
                }
            }
            free(@as(?*anyopaque, @ptrCast(color_arr.arr)));
        }
    }
}
pub export fn contains_c_extension(arg_str: [*c]const u8) c_int {
    var str = arg_str;
    _ = &str;
    var extension: [*c]const u8 = ".c";
    _ = &extension;
    var str_len: usize = strlen(str);
    _ = &str_len;
    var extension_len: usize = strlen(extension);
    _ = &extension_len;
    if (str_len >= extension_len) {
        var suffix: [*c]const u8 = str + (str_len -% extension_len);
        _ = &suffix;
        if (strcmp(suffix, extension) == @as(c_int, 0)) {
            return 1;
        }
    }
    return 0;
}
pub export fn check_for_errors(arg_args: ?*anyopaque) ?*anyopaque {
    var args = arg_args;
    _ = &args;
    var threadArgs: [*c]ThreadArgs = @as([*c]ThreadArgs, @ptrCast(@alignCast(args)));
    _ = &threadArgs;
    var loop: bool = @as(c_int, 1) != 0;
    _ = &loop;
    while (loop) {
        var path: [1035]u8 = undefined;
        _ = &path;
        var command: [1024]u8 = undefined;
        _ = &command;
        _ = sprintf(@as([*c]u8, @ptrCast(@alignCast(&command))), "gcc %s -o /dev/null -Wall -Wextra -Werror -std=c99 2> errors.cano && echo $? > success.cano", threadArgs.*.path_to_file);
        var fp: [*c]FILE = popen(@as([*c]u8, @ptrCast(@alignCast(&command))), "r");
        _ = &fp;
        if (fp == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            loop = @as(c_int, 0) != 0;
            const return_message = struct {
                var static: [21:0]u8 = "Failed to run command".*;
            };
            _ = &return_message;
            while (true) {
                var file: [*c]FILE = fopen("logs/cano.log", "a");
                _ = &file;
                if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    _ = fprintf(file, "%s:%d: Failed to run command\n", "src/tools.c", @as(c_int, 285));
                    _ = fclose(file);
                }
                if (!false) break;
            }
            return @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&return_message.static)))));
        }
        _ = pclose(fp);
        var should_check_for_errors: [*c]FILE = fopen("success.cano", "r");
        _ = &should_check_for_errors;
        if (should_check_for_errors == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            loop = @as(c_int, 0) != 0;
            while (true) {
                var file: [*c]FILE = fopen("logs/cano.log", "a");
                _ = &file;
                if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    _ = fprintf(file, "%s:%d: Failed to open file\n", "src/tools.c", @as(c_int, 294));
                    _ = fclose(file);
                }
                if (!false) break;
            }
            return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
        }
        while (fgets(@as([*c]u8, @ptrCast(@alignCast(&path))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([1035]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))))), should_check_for_errors) != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
            while (true) {
                var file: [*c]FILE = fopen("logs/cano.log", "a");
                _ = &file;
                if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    _ = fprintf(file, "%s:%d: return code: %s\n", "src/tools.c", @as(c_int, 298), @as([*c]u8, @ptrCast(@alignCast(&path))));
                    _ = fclose(file);
                }
                if (!false) break;
            }
            if (!(strcmp(@as([*c]u8, @ptrCast(@alignCast(&path))), "0") == @as(c_int, 0))) {
                var file_contents: [*c]FILE = fopen("errors.cano", "r");
                _ = &file_contents;
                if (fp == @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    loop = @as(c_int, 0) != 0;
                    while (true) {
                        var file: [*c]FILE = fopen("logs/cano.log", "a");
                        _ = &file;
                        if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                            _ = fprintf(file, "%s:%d: Failed to open file\n", "src/tools.c", @as(c_int, 303));
                            _ = fclose(file);
                        }
                        if (!false) break;
                    }
                    return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
                }
                _ = fseek(file_contents, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 2));
                var filesize: c_long = ftell(file_contents);
                _ = &filesize;
                _ = fseek(file_contents, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))), @as(c_int, 0));
                var buffer: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(filesize + @as(c_long, @bitCast(@as(c_long, @as(c_int, 1))))))))));
                _ = &buffer;
                if (buffer == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    while (true) {
                        var file: [*c]FILE = fopen("logs/cano.log", "a");
                        _ = &file;
                        if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                            _ = fprintf(file, "%s:%d: Failed to allocate memory\n", "src/tools.c", @as(c_int, 313));
                            _ = fclose(file);
                        }
                        if (!false) break;
                    }
                    return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
                }
                _ = fread(@as(?*anyopaque, @ptrCast(buffer)), @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))), @as(c_ulong, @bitCast(filesize)), file_contents);
                (blk: {
                    const tmp = filesize;
                    if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* = '\x00';
                var bufffer: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(filesize + @as(c_long, @bitCast(@as(c_long, @as(c_int, 1))))))))));
                _ = &bufffer;
                while (fgets(@as([*c]u8, @ptrCast(@alignCast(&path))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([1035]u8) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))))))), file_contents) != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    _ = strcat(bufffer, @as([*c]u8, @ptrCast(@alignCast(&path))));
                    _ = strcat(buffer, "\n");
                }
                var return_message: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(malloc(@as(c_ulong, @bitCast(filesize + @as(c_long, @bitCast(@as(c_long, @as(c_int, 1))))))))));
                _ = &return_message;
                if (return_message == @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                    while (true) {
                        var file: [*c]FILE = fopen("logs/cano.log", "a");
                        _ = &file;
                        if (file != @as([*c]FILE, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
                            _ = fprintf(file, "%s:%d: Failed to allocate memory\n", "src/tools.c", @as(c_int, 328));
                            _ = fclose(file);
                        }
                        if (!false) break;
                    }
                    free(@as(?*anyopaque, @ptrCast(buffer)));
                    return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
                }
                _ = strcpy(return_message, buffer);
                free(@as(?*anyopaque, @ptrCast(buffer)));
                loop = @as(c_int, 0) != 0;
                _ = fclose(file_contents);
                return @as(?*anyopaque, @ptrCast(return_message));
            } else {
                loop = @as(c_int, 0) != 0;
                const return_message = struct {
                    var static: [15:0]u8 = "No errors found".*;
                };
                _ = &return_message;
                return @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&return_message.static)))));
            }
        }
    }
    return @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
}
pub export fn rgb_to_ncurses(arg_r: c_int, arg_g: c_int, arg_b: c_int) Ncurses_Color {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var color: Ncurses_Color = Ncurses_Color{
        .r = @as(c_int, 0),
        .g = 0,
        .b = 0,
    };
    _ = &color;
    color.r = @as(c_int, @intFromFloat((@as(f64, @floatFromInt(r)) / 256.0) * @as(f64, @floatFromInt(@as(c_int, 1000)))));
    color.g = @as(c_int, @intFromFloat((@as(f64, @floatFromInt(g)) / 256.0) * @as(f64, @floatFromInt(@as(c_int, 1000)))));
    color.b = @as(c_int, @intFromFloat((@as(f64, @floatFromInt(b)) / 256.0) * @as(f64, @floatFromInt(@as(c_int, 1000)))));
    return color;
}

pub export fn init_ncurses_color(arg_id: c_int, arg_r: c_int, arg_g: c_int, arg_b: c_int) void {
    var id = arg_id;
    _ = &id;
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var color: Ncurses_Color = rgb_to_ncurses(r, g, b);
    _ = &color;
    _ = init_color(@as(c_short, @bitCast(@as(c_short, @truncate(id)))), @as(c_short, @bitCast(@as(c_short, @truncate(color.r)))), @as(c_short, @bitCast(@as(c_short, @truncate(color.g)))), @as(c_short, @bitCast(@as(c_short, @truncate(color.b)))));
}
pub export fn reset_command(arg_command: [*c]u8, arg_command_s: [*c]usize) void {
    var command = arg_command;
    _ = &command;
    var command_s = arg_command_s;
    _ = &command_s;
    _ = memset(@as(?*anyopaque, @ptrCast(command)), @as(c_int, 0), command_s.*);
    command_s.* = 0;
}

pub export fn compare_name(arg_leftp: [*c]const File, arg_rightp: [*c]const File) c_int {
    var leftp = arg_leftp;
    _ = &leftp;
    var rightp = arg_rightp;
    _ = &rightp;
    return strcoll(leftp.*.name, rightp.*.name);
}
